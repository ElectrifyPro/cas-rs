pub mod expr;
pub mod error;
pub mod instruction;
pub mod item;

use cas_compute::{consts::all as all_consts, funcs::all as all_funcs};
use cas_parser::parser::ast::{Call, FuncHeader, LitSym, Stmt};
use error::{kind, Error};
use std::collections::HashMap;
use expr::compile_stmts;
pub use instruction::{Instruction, InstructionKind};
use item::{BuiltinCall, Func, FuncDecl, Item, Symbol, SymbolDecl, UserCall};
use std::ops::Range;

/// A label that can be used to reference a specific instruction in the bytecode.
///
/// The internal value is simply a unique ID that is resolved to the actual instruction during
/// execution.
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub struct Label(usize);

/// The state of the compiler.
#[derive(Clone, Debug, Default)]
pub struct CompilerState {
    /// The label pointing to the start of the current loop.
    pub loop_start: Option<Label>,

    /// The label pointing to the end of the current loop.
    pub loop_end: Option<Label>,

    /// Whether the current statement is the last statement in a block or the program, indicating
    /// that its return value is the return value of the block / program.
    pub last_stmt: bool,

    /// Whether the expression being parsed is a top-level assignment expression, indicating that
    /// its return value is not used.
    ///
    /// This is used to determine whether to use the [`Instruction::StoreVar`] or
    /// [`Instruction::AssignVar`] instruction.
    ///
    /// For example, in the following code:
    ///
    /// ```calc
    /// x = y = 2
    /// ```
    ///
    /// The `x = ...` expression is an top-level assignment expression, so its return value is not
    /// used within the same statement. However, the `y = 2` expression is not a top-level
    /// assignment, as its return value is then passed to the `x = ...` expression. In this case,
    /// the compiler will generate a [`Instruction::AssignVar`] instruction for `x` and a
    /// [`Instruction::StoreVar`] instruction for `y`.
    pub top_level_assign: bool,

    /// Path representing the current scope.
    ///
    /// A new scope is introduced inside each function definition (TODO: block scopes). When this
    /// is empty, we are currently in the global scope.
    pub path: Vec<String>,
}

/// A chunk containing a function definition.
#[derive(Clone, Debug, Default)]
pub struct Chunk {
    /// The instructions in this chunk.
    pub instructions: Vec<Instruction>,

    /// The number of arguments the function takes.
    pub arity: usize,
}

impl Chunk {
    /// Creates a new chunk with the given arity.
    pub fn new(arity: usize) -> Self {
        Self {
            instructions: Vec::new(),
            arity,
        }
    }
}

/// A compiler that provides tools to generate bytecode instructions for a virtual machine (see
/// [`Vm`]).
#[derive(Clone, Debug)]
pub struct Compiler {
    /// The bytecode chunks generated by the compiler.
    ///
    /// The entire program is represented as multiple chunks of bytecode, where each chunk
    /// represents a function body. The first chunk represents the implicit "main" function.
    pub chunks: Vec<Chunk>,

    /// Labels generated by the compiler, mapped to the index of the instruction they reference.
    ///
    /// When created, labels aren't associated with any instruction. Before the bytecode is
    /// executed, the compiler will resolve these labels to the actual instruction indices.
    pub labels: HashMap<Label, Option<(usize, usize)>>,

    /// A symbol table that maps identifiers to information about the values they represent.
    ///
    /// This is used to store information about variables and functions that are defined in the
    /// program.
    pub symbols: HashMap<String, Item>,

    /// Index of the current chunk.
    ///
    /// This value is manually updated by the compiler.
    chunk: usize,

    /// Next unique identifier for a symbol.
    next_symbol_id: usize,

    /// Holds state for the current loop.
    state: CompilerState,
}

impl Default for Compiler {
    fn default() -> Self {
        Self {
            chunks: vec![Chunk::default()], // add main chunk
            labels: Default::default(),
            symbols: Default::default(),
            chunk: 0,
            next_symbol_id: 0,
            state: Default::default(),
        }
    }
}

impl Compiler {
    /// Creates a new compiler.
    pub fn new() -> Self {
        Self::default()
    }

    /// Compiles the given type into a sequence of [`Instruction`]s.
    pub fn compile<T: Compile>(expr: T) -> Result<Self, Error> {
        let mut compiler = Self::new();
        expr.compile(&mut compiler)?;
        Ok(compiler)
    }

    /// Compiles multiple statements into a sequence of [`Instruction`]s.
    pub fn compile_program(stmts: Vec<Stmt>) -> Result<Self, Error> {
        let mut compiler = Self::new();
        compile_stmts(&stmts, &mut compiler)?;
        Ok(compiler)
    }

    /// Creates a new compilation scope with the given modified state. Compilation that occurs in
    /// this scope will then use the modified state.
    pub fn with_state<F, G>(&mut self, modify_state: F, compile: G) -> Result<(), Error>
    where
        F: FnOnce(&mut CompilerState),
        G: FnOnce(&mut Self) -> Result<(), Error>,
    {
        let old_state = self.state.clone();
        modify_state(&mut self.state);
        compile(&mut *self)?;
        self.state = old_state;
        Ok(())
    }

    /// Returns an immutable reference to the current chunk.
    pub fn chunk(&self) -> &Chunk {
        self.chunks.get(self.chunk).unwrap()
    }

    /// Returns a mutable reference to the current chunk.
    pub fn chunk_mut(&mut self) -> &mut Chunk {
        self.chunks.get_mut(self.chunk).unwrap()
    }

    /// Add an item to the symbol table at the current scope.
    ///
    /// If the item to add matches that of a builtin item, one of the following will occur:
    ///
    /// - If this function is called from the global scope, an [`kind::OverrideBuiltinConstant`] or
    /// [`kind::OverrideBuiltinFunction`] error is returned.
    /// - If this function is called anywhere else, the symbol table will successfully be updated
    /// with the new item. This item shadows the existing builtin, meaning the builtin will not be
    /// accessible until the scope in which this item was declared, ends.
    pub fn add_item(&mut self, symbol: &LitSym, item: Item) -> Result<(), Error> {
        // if we are in the global scope, ensure we don't accidentally override builtin constants
        // and functions. this is because there would be no way to access the builtin constants and
        // functions after they are overridden

        // it's ok to allow overriding in deeper scopes, as the user will still be able to access
        // the builtin constants and functions afterward

        // TODO: shadowing should probably be explicit (i.e. with `let` keyword)
        if self.state.path.is_empty() {
            match &item {
                Item::Symbol(_) => {
                    if all_consts().contains(&*symbol.name) {
                        return Err(Error::new(vec![symbol.span.clone()], kind::OverrideBuiltinConstant {
                            name: symbol.name.to_string(),
                        }));
                    }
                },
                Item::Func(_) => {
                    if all_funcs().contains_key(&*symbol.name) {
                        return Err(Error::new(vec![symbol.span.clone()], kind::OverrideBuiltinFunction {
                            name: symbol.name.to_string(),
                        }));
                    }
                },
            }
        }

        let mut table = &mut self.symbols;
        for component in self.state.path.iter() {
            if table.contains_key(component) {
                let Item::Func(func) = table.get_mut(component).unwrap() else {
                    panic!("oops");
                };
                table = &mut func.symbols;
            } else {
                panic!("oops");
            }
        }

        // add to this final table
        table.insert(symbol.name.to_string(), item);
        Ok(())
    }

    /// Creates a new chunk and a scope for compilation. All methods that edit instructions will do
    /// so to the new chunk.
    pub fn new_chunk<F>(&mut self, header: &FuncHeader, f: F) -> Result<(), Error>
        where F: FnOnce(&mut Compiler) -> Result<(), Error>
    {
        let old_chunk_idx = self.chunk;
        self.chunks.push(Chunk::new(header.params.len()));
        let new_chunk_idx = self.chunks.len() - 1;

        self.add_item(&header.name, Item::Func(FuncDecl {
            chunk: new_chunk_idx,
            signature: header.params.clone(),
            symbols: HashMap::new(),
        }))?;

        self.chunk = new_chunk_idx;
        self.state.path.push(header.name.name.to_string());
        f(self)?;
        self.state.path.pop().unwrap();
        self.chunk = old_chunk_idx;

        Ok(())
    }

    /// Resolves a path to a user-created symbol, inserting it into the symbol table if it doesn't
    /// exist.
    ///
    /// If the symbol name matches that of a builtin constant, one of the following will occur:
    ///
    /// - If this function is called from the global scope, an [`kind::OverrideBuiltinConstant`]
    /// error is returned.
    /// - If this function is called anywhere else, the symbol table will successfully be updated
    /// with the new symbol. This symbol shadows the existing builtin constant, meaning the builtin
    /// will not be accessible until the scope in which this symbol was declared, ends.
    ///
    /// Returns the unique identifier for the symbol, which can be used to reference the symbol in
    /// the bytecode.
    pub fn resolve_user_symbol_or_insert(&mut self, symbol: &LitSym) -> Result<usize, Error> {
        if self.state.path.is_empty() {
            if all_consts().contains(&*symbol.name) {
                return Err(Error::new(vec![symbol.span.clone()], kind::OverrideBuiltinConstant {
                    name: symbol.name.to_string(),
                }));
            }
        }

        // check for builtin constants
        let mut result = None;

        // then check the symbol table (including possibly variables that shadow the constant)
        let mut table = &mut self.symbols;

        if self.state.path.len() > 0 {
            // is the symbol in the global scope?
            if let Some(Item::Symbol(symbol)) = table.get(&symbol.name) {
                result = Some(symbol.id);
            }

            // work our way up to the current scope
            for component in self.state.path.iter() {
                // is the symbol in this scope?
                if let Some(Item::Symbol(symbol)) = table.get(&symbol.name) {
                    result = Some(symbol.id);
                }

                // let's check the next scope
                if table.contains_key(component) {
                    let Item::Func(func) = table.get_mut(component).unwrap() else {
                        panic!("oops");
                    };
                    table = &mut func.symbols;
                } else {
                    panic!("oops");
                }
            }
        }

        if let Some(Item::Symbol(symbol)) = table.get(&symbol.name) {
            // is the symbol in the current scope?
            Ok(symbol.id)
        } else if let Some(symbol) = result {
            // use the last one we found
            Ok(symbol)
        } else {
            // if not, insert it
            let id = self.next_symbol_id;
            table.insert(symbol.name.to_string(), Item::Symbol(SymbolDecl { id }));
            self.next_symbol_id += 1;
            Ok(id)
        }
    }

    /// Resolves a path to a symbol without inserting it into the symbol table.
    ///
    /// Returns the unique identifier for the symbol, or an error if the symbol is not found within
    /// the current scope.
    pub fn resolve_symbol(&self, symbol: &LitSym) -> Result<Symbol, Error> {
        // check for builtin constants
        let mut result = all_consts()
            .get(&*symbol.name)
            .map(|name| Symbol::Builtin(name));

        // then check the symbol table (including possibly variables that shadow the constant)
        let mut table = &self.symbols;

        if self.state.path.len() > 0 {
            // is the symbol in the global scope?
            if let Some(Item::Symbol(symbol)) = table.get(&symbol.name) {
                result = Some(Symbol::User(symbol.id));
            }

            // work our way up to the current scope
            for component in self.state.path.iter() {
                // is the symbol in this scope?
                if let Some(Item::Symbol(symbol)) = table.get(&symbol.name) {
                    result = Some(Symbol::User(symbol.id));
                }

                // let's check the next scope
                if table.contains_key(component) {
                    let Item::Func(func) = table.get(component).unwrap() else {
                        panic!("oops");
                    };
                    table = &func.symbols;
                } else {
                    panic!("oops");
                }
            }
        }

        if let Some(Item::Symbol(symbol)) = table.get(&symbol.name) {
            // is the symbol in the current scope?
            Ok(Symbol::User(symbol.id))
        } else if let Some(symbol) = result {
            // use the last one we found
            Ok(symbol)
        } else {
            // not found
            Err(Error::new(vec![symbol.span.clone()], kind::UnknownVariable {
                name: symbol.name.clone(),
            }))
        }
    }

    /// Resolves a path to a function.
    ///
    /// The function call must match the function's signature. An error is returned if this is not
    /// the case, or if the function does not exist.
    ///
    /// Returns the index of the chunk containing the function.
    pub fn resolve_function(&self, call: &Call) -> Result<Func, Error> {
        // check for native functions
        let mut result = all_funcs()
            .get(&*call.name.name)
            .map(|func| Func::Builtin(BuiltinCall {
                builtin: func.as_ref(),
                num_given: call.args.len(),
            }));

        // then check the symbol table (including possibly functions that shadow native functions)
        let mut table = &self.symbols;

        if self.state.path.len() > 0 {
            // is the function in the global scope?
            if let Some(Item::Func(func)) = table.get(&call.name.name) {
                result = Some(Func::User(UserCall {
                    chunk: func.chunk,
                    signature: func.signature.clone(),
                    num_given: call.args.len(),
                }));
            }

            // work our way up to the current scope
            // if we find items with the same name, replace result
            for component in self.state.path.iter() {
                if table.contains_key(component) {
                    let Item::Func(func) = table.get(component).unwrap() else {
                        panic!("oops");
                    };
                    // result = Some(Func::User(func.chunk)); // TODO what??
                    table = &func.symbols;
                } else {
                    break;
                }
            }
        }

        // found matching function; now verify arg count (types are checked at runtime)
        if let Some(Item::Func(func)) = table.get(&call.name.name) {
            // is the function in the current scope?
            func.check_call(call)?;
            Ok(Func::User(UserCall {
                chunk: func.chunk,
                signature: func.signature.clone(),
                num_given: call.args.len(),
            }))
        } else if let Some(func) = result {
            // use the last one we found
            func.check_call(call)?;
            Ok(func)
        } else {
            // not found
            Err(Error::new(vec![call.name.span.clone()], kind::UnknownFunction {
                name: call.name.name.to_string(),
                suggestions: Vec::new(), // TODO
            }))
        }
    }

    /// Adds an instruction to the current chunk with no associated source code span.
    pub fn add_instr(&mut self, instruction: impl Into<Instruction>) {
        let chunk = self.chunk_mut();
        chunk.instructions.push(instruction.into());
    }

    /// Adds an instruction to the current chunk with an associated source code span(s).
    pub fn add_instr_with_spans(
        &mut self,
        instruction: impl Into<Instruction>,
        spans: Vec<Range<usize>>,
    ) {
        let mut instruction = instruction.into();
        instruction.spans = spans;
        let chunk = self.chunk_mut();
        chunk.instructions.push(instruction);
    }

    /// Replaces an instruction at the given index in the current chunk with a new instruction.
    pub fn replace_instr(&mut self, idx: usize, instruction: Instruction) {
        let chunk = self.chunk_mut();
        chunk.instructions[idx] = instruction;
    }

    /// Creates a unique label with no associated instruction. This label can be used to reference
    /// a specific instruction in the bytecode.
    pub fn new_unassociated_label(&mut self) -> Label {
        let label = Label(self.labels.len());
        self.labels.insert(label, None);
        label
    }

    /// Creates a unique label pointing to the end of the currently generated bytecode in the
    /// current chunk.
    ///
    /// When this method is called and [`Compile::compile`] is called immediately after, the label
    /// will point to the first instruction generated by the compilation.
    pub fn new_end_label(&mut self) -> Label {
        let label = Label(self.labels.len());
        let chunk_instrs = self.chunk().instructions.len();
        self.labels.insert(label, Some((self.chunk, chunk_instrs)));
        label
    }

    /// Associates the given label with the end of the currently generated bytecode.
    ///
    /// This is useful for creating labels that point to the end of a loop, for example.
    pub fn set_end_label(&mut self, label: Label) {
        let chunk_instrs = self.chunk().instructions.len();
        self.labels.insert(label, Some((self.chunk, chunk_instrs)));
    }
}

/// Trait for types that can be compiled into bytecode [`Instruction`]s.
///
/// The compiler is responsible for converting a CalcScript abstract syntax tree into a bytecode
/// representation that can be executed by the [`Vm`](crate::vm::Vm). The available instructions
/// are defined in the [`Instruction`](crate::instruction::Instruction) enum.
///
/// The compiler is implemented as a visitor over the AST, and is responsible for generating the
/// bytecode instructions that correspond to the AST nodes. The compiler is implemented as a
/// struct that implements the [`Visitor`](crate::visitor::Visitor) trait.
pub trait Compile {
    /// Compiles the type into a sequence of [`Instruction`]s.
    fn compile(&self, compiler: &mut Compiler) -> Result<(), Error>;
}

impl<T: Compile> Compile for &T {
    fn compile(&self, compiler: &mut Compiler) -> Result<(), Error> {
        (*self).compile(compiler)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use cas_parser::parser::{ast::stmt::Stmt, Parser};

    /// Compile the given source code.
    fn compile(source: &str) -> Result<Compiler, Error> {
        let mut parser = Parser::new(source);
        let stmts = parser.try_parse_full_many::<Stmt>().unwrap();

        Compiler::compile_program(stmts)
    }

    #[test]
    fn function_declaration() {
        compile("f(x) = {
    g(x) = {
        h(x) = x
        h(x) % 2 == 0
    }
    x % 3 == 0 && g(x)
}

f(18)").unwrap();
    }

    #[test]
    fn scoping() {
        let err = compile("f() = j + 6
g() = {
    j = 10
    f()
}
g()").unwrap_err();

        // error is in the definition of `f`
        // variable `j` is defined in `g`, so `f` can only access it if `x` is passed as an
        // argument, or `j` is in a higher scope
        assert_eq!(err.spans[0], 6..7);
    }

    #[test]
    fn shadowing() {
        compile("pi = 5").unwrap_err();
        compile("f() = pi = 5").unwrap(); // implicit shadowing occurs in non-global scopes
    }

    #[test]
    fn define_and_call() {
        compile("f(x) = return x + 1/sqrt(x)
g(x, y) = f(x) + f(y)
g(2, 3)").unwrap();
    }

    #[test]
    fn derivative() {
        compile("f(x) = x^2; f'(2)").unwrap();
        compile("ncr''(5, 3)").unwrap_err();
    }

    #[test]
    fn list_index() {
        compile("arr = [1, 2, 3]
arr[0] = 5
arr[0] + arr[1] + arr[2] == 10").unwrap();
    }
}
