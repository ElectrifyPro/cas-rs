pub mod expr;
pub mod frame;
pub mod instruction;

use cas_parser::parser::ast::Stmt;
use std::collections::HashMap;
use expr::compile_stmts;
pub use instruction::Instruction;

/// A label that can be used to reference a specific instruction in the bytecode.
///
/// The internal value is simply a unique ID that is resolved to the actual instruction during
/// execution.
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub struct Label(usize);

/// The state of the compiler.
#[derive(Clone, Debug, Default)]
pub struct CompilerState {
    /// The label pointing to the start of the current loop.
    pub loop_start: Option<Label>,

    /// The label pointing to the end of the current loop.
    pub loop_end: Option<Label>,

    /// Whether the current statement is the last statement in a block or the program, indicating
    /// that its return value is the return value of the block / program.
    pub last_stmt: bool,

    /// Whether the expression being parsed is a top-level assignment expression, indicating that
    /// its return value is not used.
    ///
    /// This is used to determine whether to use the [`Instruction::StoreVar`] or
    /// [`Instruction::AssignVar`] instruction.
    ///
    /// For example, in the following code:
    ///
    /// ```calc
    /// x = y = 2
    /// ```
    ///
    /// The `x = ...` expression is an top-level assignment expression, so its return value is not
    /// used within the same statement. However, the `y = 2` expression is not a top-level
    /// assignment, as its return value is then passed to the `x = ...` expression. In this case,
    /// the compiler will generate a [`Instruction::AssignVar`] instruction for `x` and a
    /// [`Instruction::StoreVar`] instruction for `y`.
    pub top_level_assign: bool,
}

/// A compiler that provides tools to generate bytecode instructions for a virtual machine (see
/// [`Vm`]).
#[derive(Debug, Default)]
pub struct Compiler {
    /// The bytecode instructions generated by the compiler.
    pub instructions: Vec<Instruction>,

    /// Labels generated by the compiler, mapped to the index of the instruction they reference.
    ///
    /// When created, labels aren't associated with any instruction. Before the bytecode is
    /// executed, the compiler will resolve these labels to the actual instruction indices.
    pub labels: HashMap<Label, Option<usize>>,

    /// Holds state for the current loop.
    state: CompilerState,
}

impl Compiler {
    /// Creates a new compiler.
    pub fn new() -> Self {
        Self::default()
    }

    /// Compiles the given type into a sequence of [`Instruction`]s.
    pub fn compile<T: Compile>(expr: T) -> Self {
        let mut compiler = Self::new();
        expr.compile(&mut compiler);
        compiler
    }

    /// Compiles multiple statements into a sequence of [`Instruction`]s.
    pub fn compile_program(stmts: Vec<Stmt>) -> Self {
        let mut compiler = Self::new();
        compile_stmts(&stmts, &mut compiler);
        compiler
    }

    /// Creates a new compilation scope with the given modified state. Compilation that occurs in
    /// this scope will then use the modified state.
    pub fn with_state<F, G>(&mut self, modify_state: F, compile: G)
    where
        F: FnOnce(&mut CompilerState),
        G: FnOnce(&mut Self),
    {
        let old_state = self.state.clone();
        modify_state(&mut self.state);
        compile(&mut *self);
        self.state = old_state;
    }

    /// Adds an instruction to the bytecode.
    pub fn add_instr(&mut self, instruction: Instruction) {
        self.instructions.push(instruction);
    }

    /// Replaces an instruction at the given index with a new instruction.
    pub fn replace_instr(&mut self, idx: usize, instruction: Instruction) {
        self.instructions[idx] = instruction;
    }

    /// Creates a unique label with no associated instruction. This label can be used to reference
    /// a specific instruction in the bytecode.
    pub fn new_unassociated_label(&mut self) -> Label {
        let label = Label(self.labels.len());
        self.labels.insert(label, None);
        label
    }

    /// Creates a unique label pointing to the end of the currently generated bytecode.
    ///
    /// When this method is called and [`Compile::compile`] is called immediately after, the label
    /// will point to the first instruction generated by the compilation.
    pub fn new_end_label(&mut self) -> Label {
        let label = Label(self.labels.len());
        self.labels.insert(label, Some(self.instructions.len()));
        label
    }

    /// Associates the given label with the end of the currently generated bytecode.
    ///
    /// This is useful for creating labels that point to the end of a loop, for example.
    pub fn set_end_label(&mut self, label: Label) {
        self.labels.insert(label, Some(self.instructions.len()));
    }
}

/// Trait for types that can be compiled into bytecode [`Instruction`]s.
///
/// The compiler is responsible for converting a CalcScript abstract syntax tree into a bytecode
/// representation that can be executed by the [`Vm`](crate::vm::Vm). The available instructions
/// are defined in the [`Instruction`](crate::instruction::Instruction) enum.
///
/// The compiler is implemented as a visitor over the AST, and is responsible for generating the
/// bytecode instructions that correspond to the AST nodes. The compiler is implemented as a
/// struct that implements the [`Visitor`](crate::visitor::Visitor) trait.
pub trait Compile {
    /// Compiles the type into a sequence of [`Instruction`]s.
    fn compile(&self, compiler: &mut Compiler);
}
